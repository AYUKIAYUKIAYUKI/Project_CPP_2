//============================================================================
//
// キャラクター [character.cpp]
// Author : 福田歩希
//
//============================================================================

//****************************************************
// インクルードファイル
//****************************************************
#include "character.h"
#include "field_manager.h"

//****************************************************
// usingディレクティブ
//****************************************************
using namespace abbr;

//============================================================================
// 
// publicメンバ
// 
//============================================================================

//============================================================================
// コンストラクタ
//============================================================================
CCharacter::CCharacter(LAYER Layer) :
	CMotion_Set{ Layer },
	m_fCorrectCoef{ 0.0f },
	m_fDirection{ 0.0f },
	m_fDirectionTarget{ 0.0f },
	m_fMoveSpeed{ 0.0f },
	m_RotTarget{ VEC3_INIT },
	m_PosTarget{ VEC3_INIT },
	m_fVelY{ 0.0f },
	m_nLife{ 0 }
{

}

//============================================================================
// デストラクタ
//============================================================================
CCharacter::~CCharacter()
{

}

//============================================================================
// 初期設定
//============================================================================
HRESULT CCharacter::Init()
{
	// モーションセットの初期設定
	if (FAILED(CMotion_Set::Init()))
	{
		return E_FAIL;
	}

	return S_OK;
}

//============================================================================
// 終了処理
//============================================================================
void CCharacter::Uninit()
{
	// モーションセットの終了処理
	CMotion_Set::Uninit();
}

//============================================================================
// 更新処理
//============================================================================
void CCharacter::Update()
{
	// 目標値への補正
	CorrectToTarget();

	// 体力の調整
	AdjustLife();

	// シンクロパラメータを設定
	SetSyncRot(GetRot());
	SetSyncPos(GetPos());

	// モーションセットの更新処理
	CMotion_Set::Update();
}

//============================================================================
// 描画処理
//============================================================================
void CCharacter::Draw()
{
	// モーションセットの描画処理
	CMotion_Set::Draw();
}

//============================================================================
// 左右どちらを向いているか判定
//============================================================================
bool CCharacter::CheckFacingSide()
{
	// キャラクターの向いている方向のベクトルを作成
	Vec3 CharacterFacing =
	{
		-sinf(GetRot().y),
		0.0f,
		-cosf(GetRot().y)
	};

	// 原点からキャラクターのいる場所への方向ベクトルを作成
	Vec3 CharacterPosVec = GetPos() - VEC3_INIT;
	D3DXVec3Normalize(&CharacterPosVec, &CharacterPosVec);

	// 原点からキャラクター向きへの方向ベクトルを作成
	Vec3 FacingVec = CharacterFacing - VEC3_INIT;
	D3DXVec3Normalize(&FacingVec, &FacingVec);

	// 2本の方向ベクトルの外積を作成
	float fCross = (CharacterPosVec.x * FacingVec.z) - (CharacterPosVec.z * FacingVec.x);

#if 0 // 値確認用
	ImGui::SetNextWindowSize({ -1, -1 });
	ImGui::SetNextWindowPos({ 0, 0 }, ImGuiCond_FirstUseEver);
	if (ImGui::Begin("Test")) {
		ImGui::Text("cross:%f", fCross);
		ImGui::End();
	}
#endif

	// 外積の正負に応じて向いている方向の判定のみを返す
	if (fCross < 0.0f)
		return false;	// 左ならfalseを
	else
		return true;	// 右ならtrueを
}

//============================================================================
// 補間強度を設定
//============================================================================
void CCharacter::SetCorrectCoef(float fCoef)
{
	m_fCorrectCoef = fCoef;
}

//============================================================================
// 方角を取得
//============================================================================
const float& CCharacter::GetDirection() const
{
	return m_fDirection;
}

//============================================================================
// 方角を設定
//============================================================================
void CCharacter::SetDirection(float fDirection)
{
	m_fDirection = fDirection;
}

//============================================================================
// 目標方角を取得
//============================================================================
const float& CCharacter::GetDirectionTarget() const
{
	return m_fDirectionTarget;
}

//============================================================================
// 目標方角を設定
//============================================================================
void CCharacter::SetDirectionTarget(float fDirection)
{
	m_fDirectionTarget = fDirection;
}

//============================================================================
// 移動速度を取得
//============================================================================
const float& CCharacter::GetMoveSpeed() const
{
	return m_fMoveSpeed;
}

//============================================================================
// 移動速度を設定
//============================================================================
void CCharacter::SetMoveSpeed(float fMoveSpeed)
{
	m_fMoveSpeed = fMoveSpeed;
}

//============================================================================
// 目標向きを取得
//============================================================================
const D3DXVECTOR3& CCharacter::GetRotTarget() const
{
	return m_RotTarget;
}

//============================================================================
// 目標向きを設定
//============================================================================
void CCharacter::SetRotTarget(D3DXVECTOR3 RotTarget)
{
	m_RotTarget = RotTarget;
}

//============================================================================
// 目標座標を取得
//============================================================================
const D3DXVECTOR3& CCharacter::GetPosTarget() const
{
	return m_PosTarget;
}

//============================================================================
// 目標座標を設定
//============================================================================
void CCharacter::SetPosTarget(D3DXVECTOR3 PosTarget)
{
	m_PosTarget = PosTarget;
}

//============================================================================
// Y軸の加速度を取得
//============================================================================
const float& CCharacter::GetVelY() const
{
	return m_fVelY;
}

//============================================================================
// Y軸の加速度を設定
//============================================================================
void CCharacter::SetVelY(float fVelY)
{
	m_fVelY = fVelY;
}

//============================================================================
// 体力を取得
//============================================================================
const int& CCharacter::GetLife() const
{
	return m_nLife;
}

//============================================================================
// 体力を設定
//============================================================================
void CCharacter::SetLife(int nLife)
{
	m_nLife = nLife;
}

//============================================================================
// 
// protectedメンバ
// 
//============================================================================

//============================================================================
// 目標値への補正
//============================================================================
void CCharacter::CorrectToTarget()
{
	// 目標方角へ向ける
	utility::AdjustDirection(m_fDirectionTarget, m_fDirection);	// 方角の差を補間
	m_fDirection += (m_fDirectionTarget - m_fDirection) * m_fCorrectCoef;

	// 目標向きへ向ける
	Vec3 NewRot = GetRot();
	utility::AdjustAngle(NewRot.y, m_RotTarget.y);	// 角度の差を補正
	NewRot += (m_RotTarget - NewRot) * 0.1f;
	SetRot(NewRot);

	// 目標座標へ移動
	Vec3 NewPos = GetPos();
	NewPos += (m_PosTarget - NewPos) * m_fCorrectCoef;
	SetPos(NewPos);
}

//============================================================================
// 高さを補正
//============================================================================
void CCharacter::AdjustHeight()
{
	// 目標座標をY軸の加速度分変動する
	Vec3 NewPosTarget = GetPosTarget();
	NewPosTarget.y += GetVelY();
	SetPosTarget(NewPosTarget);

	// 高さの目標に下限を設定
	if (GetPosTarget().y < 0.0f)
	{
		// 目標座標を下限に固定
		NewPosTarget.y = 0.0f;
		SetPosTarget(NewPosTarget);

		// Y軸方向の加速度を初期化
		SetVelY(0.0f);
	}
}

//============================================================================
// 体力の調整
//============================================================================
void CCharacter::AdjustLife()
{
	// 最低値を下回らないように調整
	if (m_nLife < 0)
	{
		m_nLife = 0;
	}
}

//============================================================================
// 目標向きを移動方向から自動で設定
//============================================================================
void CCharacter::AutoSetRotTarget()
{
	const Vec3& MoveVec = m_PosTarget - GetPos();	// 移動方向のベクトルを作成
	m_RotTarget.y = atan2f(-MoveVec.x, -MoveVec.z);	// 目標向きを移動方向に
}

//============================================================================
// ダメージを受ける
//============================================================================
void CCharacter::SetDamage(int nDamage)
{
	/* オーバーライド用 */
	nDamage;
}

//============================================================================
// 目標座標を方角から自動で設定
//============================================================================
void CCharacter::AutoSetPosTarget()
{
	m_PosTarget.x = cosf(m_fDirectionTarget) * CField_Manager::FIELD_RADIUS;	// X方向の目標座標を設定
	m_PosTarget.z = sinf(m_fDirectionTarget) * CField_Manager::FIELD_RADIUS;	// Z方向の目標座標を設定
}

//============================================================================
// モーションをセット
//============================================================================
void CCharacter::SetMotion(LAYER Layer, JSON Json)
{
	// モーションセットクラスにモーション情報を渡す
	CMotion_Set::SetMotion(Layer, Json);
}